---
layout: post
title: "DFS와 BFS 기본 뼈대 문제"
date: 2021-05-20
excerpt: ""
tag:
- Algorithm
category: [Algorithm]
comments: true
---

#  백준 1260 풀이

```c++
#include <cstdio>
#include<cmath>
#include<iostream>
#include<vector>
#include<algorithm>
#include<queue>
using namespace std;

bool check[1001];
vector<int> a[1001];



void dfs(int x){
    check[x] = true;
    printf("%d ", x);
    for(int i=0; i<a[x].size(); i++){
        int y = a[x][i];
        if(check[y]==false){
            dfs(y);
        }
    }
}

void bfs(int x){
    queue<int> q;
    memset(check,false,sizeof(check));
    check[x] = true;
    q.push(x);
    while(!q.empty()){
        int f = q.front();
        q.pop();
		printf("%d ", f);
        for(int i=0; i<a[f].size(); i++){
            int y = a[f][i];
            if(check[y]==false){
                check[y] = true;
                q.push(y);
            }
        }
    }

}


int main(){
    int n, m, start;
    scanf("%d %d %d", &n, &m, &start);
    for(int i=0; i<m; i++){
        int u, v;
        scanf("%d %d", &u, &v);
        a[u].push_back(v);
        a[v].push_back(u);
    }

    for(int i=1; i<=n; i++){
        sort(a[i].begin(), a[i].end());
    }

    dfs(start);
	printf("\n");
    bfs(start);
	return 0;

}


```

# 촌수계산 (백준)

```c++
#include <vector>
#include <iostream>
#include <string>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>

using namespace std;

vector<int> rel[101];
bool visit[101];

int n;
int t1, t2;
int relNum;
int res;

void dfs(int x, int y, int cnt){

    visit[x] = true;
    if(x == y){
        res = cnt; 
    }
    for(int i=0; i<rel[x].size(); i++){
        int next = rel[x][i];
        if(!visit[next]){
            dfs(next, y, cnt+1);
        }
    }
}


int main(){
    cin >> n >> t1 >> t2 >> relNum;


    for(int i=0; i<relNum; i++){
        int u, v;
        scanf("%d %d", &u, &v);
        rel[u].push_back(v);
        rel[v].push_back(u);
    }

    dfs(t1, t2, 0);
   


    printf("%d", res);

}
```


# 타겟넘버 - 프로그래머스

- n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다

-1+1+1+1+1 = 3
+1-1+1+1+1 = 3
+1+1-1+1+1 = 3
+1+1+1-1+1 = 3
+1+1+1+1-1 = 3


```c++
#include <string>
#include <vector>

using namespace std;

int answer = 0;

void dfs(vector<int> &numbers, int &target, int sum = 0, int cnt = 0){
    if(cnt == numbers.size()){
        if(target == sum){
            answer++;
        }
        return;
    }

    dfs(numbers, target, sum + numbers[cnt], cnt + 1);
    dfs(numbers, target, sum - numbers[cnt], cnt + 1);
}
int solution(vector<int> numbers, int target) {
    
    dfs(numbers, target);
    return answer;
}
```


# 숫자판 점프(백준)

```c++
#include <iostream>
#include <vector>
#include <algorithm>
 
using namespace std;

int map[6][6];
bool visit[1000000];
int ans;

int dx[] = {-1, 1, 0, 0};
int dy[] = {0, 0, 1, -1};

void dfs(int x, int y, int sum, int cnt){
    if(cnt == 6){
        if(!visit[sum]){
            visit[sum] = true;
            ans++;
            
        }
        return;
    }
    for(int i=0; i<4; i++){
        int X = x + dx[i];
        int Y = y + dy[i];
        if(X >= 0 && Y>=0 && X<5 && Y<5){
            dfs(X, Y, sum*10 + map[X][Y] ,cnt+1);
        }
        
    }    
}

int main(){
    for(int i=0; i<5; i++){
        for(int j=0; j<5; j++){
            int m;
            scanf("%d", &m);
            map[i][j] = m;
        }
    }


    for(int i=0; i<5; i++){
        for(int j=0; j<5; j++){
            dfs(i, j, map[i][j], 1);
        }
    }

    printf("%d", ans);

}
```



# 최단거리 구하기 (BFS)

## 미로 탐색(백준)

- 문자열을 2차원배열에 집어넣을 때, 문자열을 vector로 받아서 입력 하지 않기

- 최단거리 구할 때 아이디어 :  check[nx][ny] = check[x][y] + 1;

<img src = "https://traveloving2030.github.io/jiwon/assets/img/post/알고리즘/4.PNG" width = "70%" />

```c++
#include <vector>
#include <iostream>
#include <string>
#include <cstdio>
#include <algorithm>
#include <stack>
#include <queue>

using namespace std;

int n, m;
char map[101][101];
bool visit[101][101];
int check[101][101];
int dx[] = {0, 0, -1, 1};
int dy[] = {1, -1, 0, 0};

queue<pair<int, int>> q;

vector<string> s;

void bfs(int x, int y){
    visit[x][y] = true;    
    q.push(make_pair(x, y));
    while(!q.empty()){
        int x = q.front().first;
        int y = q.front().second;
        q.pop();


        for(int i=0; i<4; i++){
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(0 <= nx  && 0<= ny && nx < n && ny < m){
                if(!visit[nx][ny] && map[nx][ny] == '1'){
                    check[nx][ny] = check[x][y] + 1;
                    visit[nx][ny] = true;
                    q.push(make_pair(nx, ny));
                }
            }
        }
    }
}

int main(){
    scanf("%d %d", &n, &m);

	for (int i = 0; i < n; i++)
	{
		scanf("%s", map[i]);
	}

    bfs(0, 0);

    printf("%d", check[n-1][m-1] + 1);
}
```

